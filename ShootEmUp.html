<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Addictive Shooter Game + Black Hole Power</title>
<style>
body { margin:0; overflow:hidden; background:#111; font-family:sans-serif; }
canvas { display:block; margin:auto; background:#222; }
#score {
  position:absolute; top:10px; left:10px; 
  color:white; font-size:30px; font-weight:bold;
  transition: transform 0.2s ease, color 0.2s ease, text-shadow 0.2s ease;
}
#score.pop {
  transform: scale(1.6);
  color: gold;
  text-shadow: 0 0 20px yellow;
}
#pausedText {
  position:absolute; 
  top:50%; left:50%; 
  transform:translate(-50%, -50%);
  text-align:center;
  color:white;
  display:none;
}
#pausedText h1 { font-size:80px; margin:0; }
#pausedText p { font-size:24px; margin:10px 0 0 0; }
#goBack {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  color: white;
  background: #333;
  padding: 10px 20px;
  text-decoration: none;
  border-radius: 8px;
  font-family: sans-serif;
  font-size: 18px;
}
#goBack:hover { background: #555; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="pausedText">
  <h1>PAUSED</h1>
  <p>Press R to resume</p>
</div>

<canvas id="gameCanvas" width="800" height="600"></canvas>
<a id="goBack" href="index.html">Go Back</a>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const scoreDisplay = document.getElementById("score");
const pausedText = document.getElementById("pausedText");

function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

let mouse = {x: canvas.width/2, y: canvas.height/2};
canvas.addEventListener("mousemove", e=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});

class Player {
  constructor(){
    this.x = canvas.width/2;
    this.y = canvas.height/2;
    this.radius = 15;
    this.color = "cyan";
    this.speed = 5;
    this.shielded = false;
  }
  move(){
    const dx = mouse.x - this.x;
    const dy = mouse.y - this.y;
    const distance = Math.hypot(dx,dy);
    if(distance>1){
      const speed = Math.min(distance*0.1,this.speed);
      this.x += dx/distance*speed;
      this.y += dy/distance*speed;
    }
    this.x = Math.max(this.radius, Math.min(canvas.width-this.radius, this.x));
    this.y = Math.max(this.radius, Math.min(canvas.height-this.radius, this.y));
  }
  draw(){
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius,0,Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
    if(this.shielded){
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius+8, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(0,200,255,0.7)";
      ctx.lineWidth = 4;
      ctx.stroke();
    }
  }
}

class Bullet {
  constructor(x,y,targetX,targetY){
    this.x=x; this.y=y;
    const angle = Math.atan2(targetY - y, targetX - x);
    this.dx=Math.cos(angle)*10;
    this.dy=Math.sin(angle)*10;
    this.radius=5; this.color="yellow";
  }
  update(){ this.x+=this.dx; this.y+=this.dy; }
  draw(){
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fillStyle=this.color; ctx.fill();
  }
}

class Enemy {
  constructor(type="red"){
    this.type = type;
    this.radius = 20 + Math.random()*10;
    const edge = Math.floor(Math.random()*4);
    if(edge===0){ this.x=-this.radius; this.y=Math.random()*canvas.height; }
    if(edge===1){ this.x=canvas.width+this.radius; this.y=Math.random()*canvas.height; }
    if(edge===2){ this.x=Math.random()*canvas.width; this.y=-this.radius; }
    if(edge===3){ this.x=Math.random()*canvas.width; this.y=canvas.height+this.radius; }
    this.color = type==="purple"?"purple":"red";
    this.speed = 0.5 + Math.random()*0.5;
    this.health = type==="purple"?2:1;
  }
  move(player){
    const dx = player.x - this.x;
    const dy = player.y - this.y;
    const d = Math.hypot(dx,dy);
    if(d>0){ this.x += dx/d*this.speed; this.y += dy/d*this.speed; }
  }
  draw(){
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fillStyle = this.color; ctx.fill();
  }
}

class Particle {
  constructor(x,y,color,size=2){
    this.x=x; this.y=y; this.radius=size; this.color=color;
    this.dx=(Math.random()-0.5)*6; this.dy=(Math.random()-0.5)*6; this.life=30;
  }
  update(){ this.x+=this.dx; this.y+=this.dy; this.life--; }
  draw(){
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fillStyle=this.color; ctx.fill();
  }
}

class Drop {
  constructor(x,y,type){
    this.x=x; this.y=y; this.radius=15; this.type=type; this.life=600;
  }
  draw(){
    ctx.font="20px Arial";
    ctx.textAlign="center";
    if(this.type==="bomb") ctx.fillText("ðŸ’£",this.x,this.y);
    if(this.type==="shield") ctx.fillText("ðŸ›¡ï¸",this.x,this.y);
    if(this.type==="blackhole") ctx.fillText("ðŸŒ€",this.x,this.y);
  }
}

class BlackHole {
  constructor(x,y){
    this.x=x; this.y=y; this.radius=20; this.life=300;
  }
  update(){
    this.life--;
    this.radius = 20 + Math.sin(Date.now()/100)*5;
  }
  draw(){
    ctx.beginPath();
    const gradient = ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.radius);
    gradient.addColorStop(0,"black");
    gradient.addColorStop(1,"purple");
    ctx.fillStyle = gradient;
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fill();
  }
}

let player, bullets, enemies, particles, drops, blackHoles;
let score=0;
let shootCooldown=0;
let shooting=true; // ðŸ”¹ Always shooting now
let gameOver=false;
let paused=false;
let enemySpawnCounter=0;

window.addEventListener("keydown",e=>{
  if(e.key.toLowerCase()==="p"){
    paused = !paused;
    pausedText.style.display = paused ? "block" : "none";
  }
  if(e.key.toLowerCase()==="r" && paused){
    paused=false;
    pausedText.style.display="none";
  }
});

function resetGame(){
  player = new Player();
  bullets = [];
  enemies = [];
  particles = [];
  drops = [];
  blackHoles = [];
  score = 0;
  gameOver = false;
  for(let i=0;i<5;i++) spawnEnemy();
}

function spawnEnemy(){
  const type = Math.random()<0.2?"purple":"red";
  enemies.push(new Enemy(type));
}

function popScore(){
  scoreDisplay.classList.add("pop");
  setTimeout(()=>scoreDisplay.classList.remove("pop"),200);
}

function endGame(){
  gameOver = true;
  setTimeout(()=>{
    alert("ðŸ’€ Game Over! Score: "+score);
    resetGame();
  },100);
}

function animate(){
  requestAnimationFrame(animate);

  if(gameOver || paused) return;

  ctx.fillStyle="rgba(0,0,0,0.3)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  player.move();
  player.draw();

  // ðŸ”¹ Shooting automatically
  if(shooting && shootCooldown<=0){
    bullets.push(new Bullet(player.x,player.y,mouse.x,mouse.y));
    shootCooldown=10;
  }
  if(shootCooldown>0) shootCooldown--;

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i]; b.update(); b.draw();
    if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) bullets.splice(i,1);
  }

  enemySpawnCounter++;
  if(enemySpawnCounter % 60 === 0){
    spawnEnemy();
    if(Math.random()<0.3) spawnEnemy();
  }

  for(let i=blackHoles.length-1;i>=0;i--){
    const bh = blackHoles[i];
    bh.update(); bh.draw();
    enemies.forEach(e=>{
      const dx = bh.x - e.x;
      const dy = bh.y - e.y;
      const d = Math.hypot(dx,dy);
      if(d>0 && d<400){
        e.x += dx/d * 2;
        e.y += dy/d * 2;
      }
      if(d<bh.radius){
        for(let k=0;k<20;k++) particles.push(new Particle(e.x,e.y,"purple",Math.random()*4+2));
        score++; popScore();
        enemies.splice(enemies.indexOf(e),1);
      }
    });
    if(bh.life<=0) blackHoles.splice(i,1);
  }

  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i]; e.move(player); e.draw();
    for(let j=bullets.length-1;j>=0;j--){
      const b=bullets[j];
      if(dist(e,b)<e.radius+b.radius){
        e.health--;
        bullets.splice(j,1);
        if(e.health<=0){
          for(let k=0;k<20;k++) particles.push(new Particle(b.x,b.y,e.color,Math.random()*4+2));
          score++; popScore();
          if(e.type==="purple"){
            if(Math.random()<0.33) drops.push(new Drop(e.x,e.y,"bomb"));
            else if(Math.random()<0.66) drops.push(new Drop(e.x,e.y,"shield"));
            else drops.push(new Drop(e.x,e.y,"blackhole"));
          }
          enemies.splice(i,1); spawnEnemy();
        }
        break;
      }
    }
    if(dist(e,player)<e.radius+player.radius && !player.shielded){
      endGame();
    }
  }

  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.update(); p.draw();
    if(p.life<=0) particles.splice(i,1);
  }

  for(let i=drops.length-1;i>=0;i--){
    const d=drops[i]; d.draw(); d.life--;
    if(dist(d,player)<player.radius+d.radius){
      if(d.type==="bomb"){
        enemies.forEach(e=>{
          if(dist(e,d)<200){
            for(let k=0;k<20;k++) particles.push(new Particle(e.x,e.y,"orange",Math.random()*4+2));
            score++; 
          }
        });
        enemies.length=0; for(let k=0;k<10;k++) spawnEnemy();
      }
      if(d.type==="shield"){
        player.shielded=true;
        setTimeout(()=>player.shielded=false,10000);
      }
      if(d.type==="blackhole"){
        blackHoles.push(new BlackHole(d.x,d.y));
      }
      drops.splice(i,1);
    } else if(d.life<=0) drops.splice(i,1);
  }

  scoreDisplay.textContent = "Score: "+score;
}

resetGame();
animate();
</script>
</body>
</html>
