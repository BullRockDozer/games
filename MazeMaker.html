<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<title>Random Maze Generator (Interactive Solver)</title>
<style>
  body { 
    margin: 20px; 
    background:#111; 
    color:#ddd; 
    font-family:sans-serif; 
    display: block;
  }
  canvas {
    background: #222;
    display:block;
    margin: 0 auto 20px auto;
    image-rendering: pixelated;
  }
  #controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: center;
    margin-bottom: 20px;
  }
  button, input {
    padding:8px 14px;
    font-size:16px;
    cursor:pointer;
    background:#333;
    color:#fff;
    border:1px solid #444;
    border-radius:6px;
    width: 200px;
    text-align: center;
    box-sizing: border-box;
  }
  input[type="number"] { background:#222; color:#ddd; }
  .row { display:flex; gap:8px; }
  #progressContainer {
    width: 220px;
    text-align: center;
    color: #ddd;
    font-size: 14px;
  }
  #progressBar {
    width: 100%;
    height: 12px;
    background: #222;
    border: 1px solid #444;
    border-radius: 6px;
    margin-top: 6px;
    overflow: hidden;
  }
  #progressFill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #00c853, #00b0ff);
    transition: width 0.08s linear;
  }

@media print {
#controls { display:none; }
body { background:white; color:black; }
canvas { margin:auto; background:white !important; }
} </style>

</head>
<body>

<canvas id="maze" width="600" height="600"></canvas>

<div id="controls">
  <div class="row">
    <input type="number" id="rowsInput" placeholder="Rows" value="30" min="5" max="100">
    <input type="number" id="colsInput" placeholder="Columns" value="30" min="5" max="100">
  </div>
  <button id="newMazeBtn">NEW MAZE</button>
  <button id="printBtn">PRINT MAZE</button>
  <button id="solveBtn">START SOLVE (Arrow keys / WASD / Drag)</button>
  <button id="closeSolutionBtn" style="display:none;">CLOSE SOLVE</button>
  <button id="stopSolveBtn" style="display:none;">STOP SOLVING</button>
  <button id="goBackBtn">GO BACK</button>

  <div id="progressContainer" style="display:none;">
    <div id="progressText">Progress: 0%</div>
    <div id="progressBar"><div id="progressFill"></div></div>
  </div>
</div>

<script>
const canvas = document.getElementById("maze");
const ctx = canvas.getContext("2d");

let rows = 30;
let cols = 30;
let size = 20;
const borderLineWidth = 3;

let grid = [];
let stack = [];
let mazeFinished = false;
let interactivePath = null;
let solving = false;

let visitedCount = 0;
let totalCells = 0;
let generationAttempts = 0;
const maxRegenerateAttempts = 6;

class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.visited = false;
    this.walls = { top:true, right:true, bottom:true, left:true };
  }
  draw() {
    const x = this.x * size;
    const y = this.y * size;
    ctx.strokeStyle = "black";
    ctx.lineWidth = borderLineWidth;
    ctx.lineJoin = "miter";
    if (this.walls.top)    { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+size, y); ctx.stroke(); }
    if (this.walls.right)  { ctx.beginPath(); ctx.moveTo(x+size, y); ctx.lineTo(x+size, y+size); ctx.stroke(); }
    if (this.walls.bottom) { ctx.beginPath(); ctx.moveTo(x+size, y+size); ctx.lineTo(x, y+size); ctx.stroke(); }
    if (this.walls.left)   { ctx.beginPath(); ctx.moveTo(x, y+size); ctx.lineTo(x, y); ctx.stroke(); }
  }
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function fixInputLimits() {
  const r = document.getElementById("rowsInput");
  const c = document.getElementById("colsInput");
  if (r.value > 100) r.value = 100;
  if (c.value > 100) c.value = 100;
}

function getNeighbors(cell) {
  let neighbors = [];
  const dirs = [
    { dx:0, dy:-1, wallA:"top",    wallB:"bottom" },
    { dx:1, dy:0,  wallA:"right",  wallB:"left" },
    { dx:0, dy:1,  wallA:"bottom", wallB:"top" },
    { dx:-1,dy:0,  wallA:"left",   wallB:"right" }
  ];
  for (let d of dirs) {
    let nx = cell.x + d.dx;
    let ny = cell.y + d.dy;
    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
      let neighbor = grid[ny][nx];
      if (!neighbor.visited) neighbors.push({ cell: neighbor, removeA:d.wallA, removeB:d.wallB });
    }
  }
  return neighbors;
}

function updateProgress() {
  const pct = Math.floor((visitedCount / Math.max(1, totalCells)) * 100);
  const progressContainer = document.getElementById("progressContainer");
  const progressText = document.getElementById("progressText");
  const progressFill = document.getElementById("progressFill");
  progressText.textContent = `Progress: ${pct}%`;
  progressFill.style.width = `${pct}%`;
  progressContainer.style.display = (mazeFinished ? "none" : "block");
}

function drawOuterBorder() {
  ctx.strokeStyle = "black";
  ctx.lineWidth = borderLineWidth;
  const offset = borderLineWidth / 2;
  ctx.strokeRect(offset, offset, cols * size - borderLineWidth, rows * size - borderLineWidth);
}

function drawMaze() {
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      grid[y][x].draw();
    }
  }

  drawOuterBorder();

  if (interactivePath && interactivePath.length > 0) {
    let thin = Math.max(1, Math.floor(size * 0.22));
    let bold = Math.max(1, Math.floor(size * 0.36));

    if (interactivePath.length > 2) {
      ctx.strokeStyle = "blue";
      ctx.lineWidth = thin;
      ctx.beginPath();
      const start = interactivePath[0];
      ctx.moveTo(start.x * size + size/2, start.y * size + size/2);
      for (let i = 1; i < interactivePath.length - 1; i++) {
        const p = interactivePath[i];
        ctx.lineTo(p.x * size + size/2, p.y * size + size/2);
      }
      ctx.stroke();
    }

    if (interactivePath.length > 1) {
      ctx.strokeStyle = "red";
      ctx.lineWidth = bold;
      ctx.beginPath();
      const a = interactivePath[interactivePath.length - 2];
      const b = interactivePath[interactivePath.length - 1];
      ctx.moveTo(a.x * size + size/2, a.y * size + size/2);
      ctx.lineTo(b.x * size + size/2, b.y * size + size/2);
      ctx.stroke();
    }
  }

  ctx.fillStyle = "lime";
  ctx.font = `${Math.max(12, Math.floor(size * 0.8))}px Arial`;
  ctx.textBaseline = "middle";
  ctx.fillText("S", size * 0.28, size * 0.5);
  ctx.fillStyle = "red";
  ctx.fillText("E", (cols - 1) * size + size * 0.28, (rows - 1) * size + size * 0.5);

  updateSolverButtons();
  updateProgress();
}

function isSolvable() {
  let visited = new Array(rows).fill(0).map(()=>new Array(cols).fill(false));
  let q = [{x:0,y:0}];
  visited[0][0] = true;
  while (q.length > 0) {
    const p = q.shift();
    if (p.x === cols - 1 && p.y === rows - 1) return true;
    const cell = grid[p.y][p.x];
    if (!cell.walls.top && p.y > 0 && !visited[p.y-1][p.x]) { visited[p.y-1][p.x] = true; q.push({x:p.x,y:p.y-1}); }
    if (!cell.walls.right && p.x < cols-1 && !visited[p.y][p.x+1]) { visited[p.y][p.x+1] = true; q.push({x:p.x+1,y:p.y}); }
    if (!cell.walls.bottom && p.y < rows-1 && !visited[p.y+1][p.x]) { visited[p.y+1][p.x] = true; q.push({x:p.x,y:p.y+1}); }
    if (!cell.walls.left && p.x > 0 && !visited[p.y][p.x-1]) { visited[p.y][p.x-1] = true; q.push({x:p.x-1,y:p.y}); }
  }
  return false;
}

function generateMaze() {
  fixInputLimits();
  rows = clamp(parseInt(document.getElementById("rowsInput").value) || 30, 5, 100);
  cols = clamp(parseInt(document.getElementById("colsInput").value) || 30, 5, 100);
  size = Math.floor(Math.min(canvas.width / cols, canvas.height / rows));
  if (size < 4) size = 4;

  mazeFinished = false;
  solving = false;
  interactivePath = null;
  document.getElementById("closeSolutionBtn").style.display = "none";
  document.getElementById("stopSolveBtn").style.display = "none";
  document.getElementById("progressContainer").style.display = "block";

  grid = [];
  stack = [];
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let y = 0; y < rows; y++) {
    grid[y] = [];
    for (let x = 0; x < cols; x++) {
      grid[y][x] = new Cell(x, y);
    }
  }

  totalCells = rows * cols;
  visitedCount = 0;
  generationAttempts++;

  let current = grid[0][0];
  current.visited = true;
  visitedCount++;

  function step() {
    let neighbors = getNeighbors(current);
    if (neighbors.length > 0) {
      let { cell: next, removeA, removeB } =
        neighbors[Math.floor(Math.random() * neighbors.length)];
      current.walls[removeA] = false;
      next.walls[removeB] = false;
      stack.push(current);
      next.visited = true;
      visitedCount++;
      current = next;
    } else if (stack.length > 0) {
      current = stack.pop();
    } else {
      mazeFinished = true;
      drawMaze();
      setTimeout(() => {
        const ok = isSolvable();
        if (!ok && generationAttempts < maxRegenerateAttempts) {
          console.warn("Maze failed solvability check â€” regenerating (attempt " + generationAttempts + ")");
          generateMaze();
        } else if (!ok) {
          console.error("Maze failed solvability check after maximum attempts. Proceeding anyway.");
          drawMaze();
          document.getElementById("progressContainer").style.display = "none";
        } else {
          document.getElementById("progressContainer").style.display = "none";
          generationAttempts = 0;
          drawMaze();
        }
      }, 10);
      return;
    }
    drawMaze();
    updateProgress();
    requestAnimationFrame(step);
  }

  step();
}

function updateSolverButtons() {
  const stopBtn = document.getElementById("stopSolveBtn");
  const closeBtn = document.getElementById("closeSolutionBtn");
  const solveBtn = document.getElementById("solveBtn");
  if (solving) {
    stopBtn.style.display = "inline-block";
    closeBtn.style.display = "none";
    solveBtn.style.display = "none";
  } else {
    stopBtn.style.display = "none";
    closeBtn.style.display = interactivePath ? "inline-block" : "none";
    solveBtn.style.display = "inline-block";
  }
}

function startInteractiveSolve() {
  if (!mazeFinished) return alert("Maze still generating!");
  interactivePath = [{ x: 0, y: 0 }];
  solving = true;
  drawMaze();
  updateSolverButtons();
  window.focus();
}

function movePlayer(dx, dy) {
  if (!solving) return;
  const last = interactivePath[interactivePath.length - 1];
  const nx = last.x + dx;
  const ny = last.y + dy;
  if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return;

  const cell = grid[last.y][last.x];
  if ((dx === 0 && dy === -1 && !cell.walls.top) ||
      (dx === 1 && dy === 0 && !cell.walls.right) ||
      (dx === 0 && dy === 1 && !cell.walls.bottom) ||
      (dx === -1 && dy === 0 && !cell.walls.left)) {

    const lastP = interactivePath[interactivePath.length - 1];
    if (!(lastP.x === nx && lastP.y === ny)) {
      interactivePath.push({ x: nx, y: ny });
      drawMaze();
      if (nx === cols - 1 && ny === rows - 1) {
        solving = false;
        drawMaze();
        setTimeout(() => alert("Congratulations! You solved the maze!"), 10);
      }
    }
  }
}

document.addEventListener("keydown", (e) => {
  if (!solving) return;
  const key = e.key;
  if (key === "ArrowUp" || key === "w" || key === "W") { movePlayer(0, -1); e.preventDefault(); }
  else if (key === "ArrowRight" || key === "d" || key === "D") { movePlayer(1, 0); e.preventDefault(); }
  else if (key === "ArrowDown" || key === "s" || key === "S") { movePlayer(0, 1); e.preventDefault(); }
  else if (key === "ArrowLeft" || key === "a" || key === "A") { movePlayer(-1, 0); e.preventDefault(); }
});

let isDragging = false;
canvas.addEventListener("mousedown", () => { if (solving) isDragging = true; });
canvas.addEventListener("mouseup", () => { isDragging = false; });
canvas.addEventListener("mouseleave", () => { isDragging = false; });
canvas.addEventListener("mousemove", (ev) => {
  if (!isDragging || !solving) return;
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;
  const x = Math.floor(mx / size);
  const y = Math.floor(my / size);
  if (!interactivePath) return;
  const last = interactivePath[interactivePath.length - 1];
  const dx = x - last.x;
  const dy = y - last.y;
  if (Math.abs(dx) + Math.abs(dy) !== 1) return;
  movePlayer(dx, dy);
});

document.getElementById("newMazeBtn").addEventListener("click", () => {
  if (solving) {
    if (!confirm("You're currently solving. Generate a new maze and lose progress?")) return;
  }
  generateMaze();
});

document.getElementById("printBtn").addEventListener("click", () => {
  if (solving) { alert("Cannot print while solving!"); return; }
  if (!mazeFinished) { alert("Maze is still generating!"); return; }

  drawMaze(); // just draw maze, no text
  setTimeout(() => {
    window.print();
    drawMaze();
  }, 100);
});

document.getElementById("solveBtn").addEventListener("click", () => startInteractiveSolve());

document.getElementById("closeSolutionBtn").addEventListener("click", () => {
  interactivePath = null;
  solving = false;
  drawMaze();
});

document.getElementById("stopSolveBtn").addEventListener("click", () => {
  solving = false;
  interactivePath = null;
  drawMaze();
});

document.getElementById("goBackBtn").addEventListener("click", () => {
  window.location.href = "index.html";
});

generationAttempts = 0;
generateMaze();
</script>

</body>
</html>