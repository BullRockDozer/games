<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Random Maze Generator (Interactive Solver) - Single Snake</title>
<style>
  :root {
    --bg: #111;
    --panel: #222;
    --btn: #333;
    --muted: #ddd;
  }
  html,body { height:100%; }
  body {
    margin:20px;
    background: var(--bg);
    color: var(--muted);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  #container { max-width: 960px; margin: 0 auto; display: grid; grid-template-columns: 1fr 260px; gap: 18px; }
  canvas { background: var(--panel); display:block; width:100%; height:auto; margin: 0; image-rendering: pixelated; border-radius:6px; box-shadow: 0 6px 20px rgba(0,0,0,0.6); }

  #controls {
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:stretch;
  }
  .row { display:flex; gap:8px; }
  input[type="number"], button {
    font-size:15px;
    padding:8px 10px;
    border-radius:8px;
    border:1px solid #444;
    background: var(--btn);
    color: #fff;
    box-sizing:border-box;
  }
  input[type="number"] { background:#1b1b1b; color:var(--muted); width:100%; }
  button { cursor:pointer; }
  #progressContainer { text-align:center; color:var(--muted); font-size:13px; display:none; }
  #progressBar { width:100%; height:12px; background:#111; border-radius:8px; overflow:hidden; border:1px solid #333; margin-top:6px; }
  #progressFill { height:100%; width:0%; transition: width 0.06s linear; background: linear-gradient(90deg,#00c853,#00b0ff); }

  .small { font-size:13px; padding:6px 10px; }

  #printInfo { display:none; text-align:center; color:black; font-size:14px; margin-top:8px; }

  @media print {
    body { background: white; color: black; }
    #controls { display:none !important; }
    #container { grid-template-columns: 1fr; }
    canvas { background: white !important; box-shadow:none !important; border-radius:0 !important; }
    #printInfo { display:block; }
    /* print footer style: date on first line, rows & cols under */
    #printInfo .date { font-weight:600; margin-bottom:4px; }
    #printInfo .rc { font-weight:400; }
  }

  /* small responsive */
  @media (max-width:900px) {
    #container { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<div id="container">
  <div>
    <canvas id="maze" width="720" height="720"></canvas>
    <div id="printInfo" aria-hidden="true">
      <div class="date" id="printDate"></div>
      <div class="rc" id="printRC"></div>
    </div>
  </div>

  <div id="controls" role="region" aria-label="Maze controls">
    <div class="row">
      <input id="rowsInput" type="number" value="30" min="5" max="100" aria-label="Rows">
      <input id="colsInput" type="number" value="30" min="5" max="100" aria-label="Columns">
    </div>

    <button id="newMazeBtn">NEW MAZE</button>
    <button id="printBtn">PRINT MAZE</button>
    <button id="solveBtn">START SOLVE (Arrow / WASD / Drag / Touch)</button>
    <button id="closeSolutionBtn" style="display:none;">CLOSE SOLVE</button>
    <button id="stopSolveBtn" style="display:none;">STOP SOLVING</button>
    <button id="goBackBtn">GO BACK</button>

    <div id="progressContainer">
      <div id="progressText">Progress: 0%</div>
      <div id="progressBar"><div id="progressFill"></div></div>
    </div>

    <div style="font-size:13px; color:#bbb; margin-top:6px;">
      Tip: Drag with mouse or finger to move when solving. Use arrow keys or WASD too.
    </div>
  </div>
</div>

<script>
/* ---------- single-snake recursive backtracker maze - guaranteed solvable ---------- */

const canvas = document.getElementById('maze');
const ctx = canvas.getContext('2d');

let rows = 30, cols = 30, size = 20;
const borderLineWidth = 3;
let grid = [];
let stack = [];
let mazeFinished = false;
let solving = false;
let interactivePath = null;
let totalCells = 0, visitedCount = 0;

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function fixInputLimits(){
  const r = document.getElementById('rowsInput');
  const c = document.getElementById('colsInput');
  if (r.value > 100) r.value = 100;
  if (c.value > 100) c.value = 100;
}

/* cell */
class Cell {
  constructor(x,y){
    this.x = x; this.y = y;
    this.visited = false;
    this.walls = { top:true, right:true, bottom:true, left:true };
  }
  draw(){
    const x = this.x * size;
    const y = this.y * size;
    ctx.strokeStyle = "#000";
    ctx.lineWidth = borderLineWidth;
    if (this.walls.top)    { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+size, y); ctx.stroke(); }
    if (this.walls.right)  { ctx.beginPath(); ctx.moveTo(x+size, y); ctx.lineTo(x+size, y+size); ctx.stroke(); }
    if (this.walls.bottom) { ctx.beginPath(); ctx.moveTo(x+size, y+size); ctx.lineTo(x, y+size); ctx.stroke(); }
    if (this.walls.left)   { ctx.beginPath(); ctx.moveTo(x, y+size); ctx.lineTo(x, y); ctx.stroke(); }
  }
}

/* get unvisited neighbors */
function getNeighbors(cell) {
  const neighbors = [];
  const dirs = [
    { dx:0, dy:-1, a:'top',    b:'bottom' },
    { dx:1, dy:0,  a:'right',  b:'left' },
    { dx:0, dy:1,  a:'bottom', b:'top' },
    { dx:-1,dy:0,  a:'left',   b:'right' }
  ];
  for (let d of dirs) {
    const nx = cell.x + d.dx;
    const ny = cell.y + d.dy;
    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
      const n = grid[ny][nx];
      if (!n.visited) neighbors.push({ cell: n, removeA: d.a, removeB: d.b });
    }
  }
  return neighbors;
}

/* drawing helpers */
function drawOuterBorder() {
  ctx.strokeStyle = "#000";
  ctx.lineWidth = borderLineWidth;
  ctx.strokeRect(borderLineWidth/2, borderLineWidth/2, cols*size - borderLineWidth, rows*size - borderLineWidth);
}

function updateProgress() {
  const pct = Math.floor((visitedCount / Math.max(1, totalCells)) * 100);
  const container = document.getElementById('progressContainer');
  const text = document.getElementById('progressText');
  const fill = document.getElementById('progressFill');
  text.textContent = `Progress: ${pct}%`;
  fill.style.width = `${pct}%`;
  container.style.display = mazeFinished ? 'none' : 'block';
}

/* draw maze + path + S/E */
function drawMaze(){
  // white background
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      grid[y][x].draw();
    }
  }

  drawOuterBorder();

  // interactive path lines
  if (interactivePath && interactivePath.length > 0) {
    const thin = Math.max(1, Math.floor(size * 0.18));
    const bold = Math.max(1, Math.floor(size * 0.34));

    if (interactivePath.length > 2) {
      ctx.strokeStyle = "rgba(0,120,255,0.9)";
      ctx.lineWidth = thin;
      ctx.beginPath();
      const start = interactivePath[0];
      ctx.moveTo(start.x * size + size/2, start.y * size + size/2);
      for (let i = 1; i < interactivePath.length - 1; i++) {
        const p = interactivePath[i];
        ctx.lineTo(p.x * size + size/2, p.y * size + size/2);
      }
      ctx.stroke();
    }

    if (interactivePath.length > 1) {
      ctx.strokeStyle = "rgba(255,40,40,0.95)";
      ctx.lineWidth = bold;
      ctx.beginPath();
      const a = interactivePath[interactivePath.length - 2];
      const b = interactivePath[interactivePath.length - 1];
      ctx.moveTo(a.x * size + size/2, a.y * size + size/2);
      ctx.lineTo(b.x * size + size/2, b.y * size + size/2);
      ctx.stroke();
    }
  }

  // start/end markers
  ctx.fillStyle = "lime";
  ctx.font = `${Math.max(12, Math.floor(size * 0.8))}px Arial`;
  ctx.textBaseline = "middle";
  ctx.fillText("S", size * 0.28, size * 0.5);
  ctx.fillStyle = "red";
  ctx.fillText("E", (cols - 1) * size + size * 0.28, (rows - 1) * size + size * 0.5);

  updateSolverButtons();
  updateProgress();
}

/* generate maze (recursive backtracker - single snake) */
function generateMaze() {
  fixInputLimits();
  rows = clamp(parseInt(document.getElementById('rowsInput').value) || 30, 5, 100);
  cols = clamp(parseInt(document.getElementById('colsInput').value) || 30, 5, 100);

  // compute cell size to fit canvas
  const w = canvas.width;
  const h = canvas.height;
  size = Math.floor(Math.min(w / cols, h / rows));
  if (size < 4) size = 4;

  mazeFinished = false;
  solving = false;
  interactivePath = null;
  document.getElementById('closeSolutionBtn').style.display = 'none';
  document.getElementById('stopSolveBtn').style.display = 'none';
  document.getElementById('progressContainer').style.display = 'block';

  // init grid
  grid = [];
  for (let y = 0; y < rows; y++) {
    grid[y] = [];
    for (let x = 0; x < cols; x++) {
      grid[y][x] = new Cell(x,y);
    }
  }

  totalCells = rows * cols;
  visitedCount = 0;

  // start at (0,0)
  let current = grid[0][0];
  current.visited = true;
  visitedCount++;
  stack = [];

  function step() {
    const neighbors = getNeighbors(current);
    if (neighbors.length > 0) {
      const choice = neighbors[Math.floor(Math.random() * neighbors.length)];
      const next = choice.cell;
      current.walls[choice.removeA] = false;
      next.walls[choice.removeB] = false;
      stack.push(current);
      next.visited = true;
      visitedCount++;
      current = next;
    } else if (stack.length > 0) {
      current = stack.pop();
    } else {
      // finished
      mazeFinished = true;
      drawMaze();
      return;
    }
    // draw and continue
    drawMaze();
    updateProgress();
    requestAnimationFrame(step);
  }

  step();
}

/* --------- interactive solving (keyboard, mouse drag, touch) ---------- */

function updateSolverButtons(){
  const stopBtn = document.getElementById('stopSolveBtn');
  const closeBtn = document.getElementById('closeSolutionBtn');
  const solveBtn = document.getElementById('solveBtn');
  if (solving) {
    stopBtn.style.display = 'inline-block';
    closeBtn.style.display = 'none';
    solveBtn.style.display = 'none';
  } else {
    stopBtn.style.display = 'none';
    closeBtn.style.display = interactivePath ? 'inline-block' : 'none';
    solveBtn.style.display = 'inline-block';
  }
}

function startInteractiveSolve() {
  if (!mazeFinished) return alert('Maze still generating!');
  interactivePath = [{ x:0, y:0 }];
  solving = true;
  drawMaze();
  updateSolverButtons();
  window.focus();
}

function movePlayer(dx, dy) {
  if (!solving) return;
  const last = interactivePath[interactivePath.length - 1];
  const nx = last.x + dx;
  const ny = last.y + dy;
  if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return;

  const cell = grid[last.y][last.x];
  const canMove = (dx === 0 && dy === -1 && !cell.walls.top) ||
                  (dx === 1 && dy === 0 && !cell.walls.right) ||
                  (dx === 0 && dy === 1 && !cell.walls.bottom) ||
                  (dx === -1 && dy === 0 && !cell.walls.left);

  if (!canMove) return;

  const lastP = interactivePath[interactivePath.length - 1];
  if (!(lastP.x === nx && lastP.y === ny)) {
    interactivePath.push({ x: nx, y: ny });
    drawMaze();
    if (nx === cols - 1 && ny === rows - 1) {
      solving = false;
      drawMaze();
      setTimeout(() => alert('Congratulations! You solved the maze!'), 10);
    }
  }
}

/* keyboard */
document.addEventListener('keydown', (e) => {
  if (!solving) return;
  const k = e.key;
  if (k === 'ArrowUp' || k === 'w' || k === 'W') { movePlayer(0, -1); e.preventDefault(); }
  else if (k === 'ArrowRight' || k === 'd' || k === 'D') { movePlayer(1, 0); e.preventDefault(); }
  else if (k === 'ArrowDown' || k === 's' || k === 'S') { movePlayer(0, 1); e.preventDefault(); }
  else if (k === 'ArrowLeft' || k === 'a' || k === 'A') { movePlayer(-1, 0); e.preventDefault(); }
});

/* mouse dragging */
let isDragging = false;
canvas.addEventListener('mousedown', (ev) => { if (solving) { isDragging = true; handlePointer(ev.clientX, ev.clientY); }});
window.addEventListener('mouseup', () => { isDragging = false; });
canvas.addEventListener('mousemove', (ev) => { if (isDragging && solving) handlePointer(ev.clientX, ev.clientY); });

/* touch support */
canvas.addEventListener('touchstart', (ev) => { if (solving) { isDragging = true; const t = ev.touches[0]; handlePointer(t.clientX, t.clientY); ev.preventDefault(); }}, {passive:false});
canvas.addEventListener('touchmove', (ev) => { if (isDragging && solving) { const t = ev.touches[0]; handlePointer(t.clientX, t.clientY); ev.preventDefault(); }}, {passive:false});
window.addEventListener('touchend', () => { isDragging = false; });

function handlePointer(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const mx = clientX - rect.left;
  const my = clientY - rect.top;
  const x = Math.floor(mx / size);
  const y = Math.floor(my / size);
  if (!interactivePath) return;
  const last = interactivePath[interactivePath.length - 1];
  const dx = x - last.x;
  const dy = y - last.y;
  if (Math.abs(dx) + Math.abs(dy) !== 1) return;
  movePlayer(dx, dy);
}

/* ---------- UI wiring ---------- */

document.getElementById('newMazeBtn').addEventListener('click', () => {
  if (solving) {
    if (!confirm("You're currently solving. Generate a new maze and lose progress?")) return;
  }
  generateMaze();
});

document.getElementById('printBtn').addEventListener('click', () => {
  if (solving) { alert("Cannot print while solving!"); return; }
  if (!mazeFinished) { alert("Maze is still generating!"); return; }

  // populate print info: date then rows/cols under it
  const dateEl = document.getElementById('printDate');
  const rcEl = document.getElementById('printRC');
  const now = new Date();
  dateEl.textContent = now.toLocaleDateString();
  rcEl.textContent = `Rows: ${rows}    Columns: ${cols}`;

  // small delay before print to allow printInfo to render
  setTimeout(() => {
    window.print();
    // clear after print
    setTimeout(() => { dateEl.textContent = ''; rcEl.textContent = ''; }, 200);
  }, 120);
});

document.getElementById('solveBtn').addEventListener('click', () => startInteractiveSolve());
document.getElementById('closeSolutionBtn').addEventListener('click', () => {
  interactivePath = null;
  solving = false;
  drawMaze();
});
document.getElementById('stopSolveBtn').addEventListener('click', () => {
  solving = false;
  interactivePath = null;
  drawMaze();
});
document.getElementById('goBackBtn').addEventListener('click', () => {
  // default go back page - change if you want a different target
  window.location.href = 'index.html';
});

/* ensure inputs clamp */
document.getElementById('rowsInput').addEventListener('change', fixInputLimits);
document.getElementById('colsInput').addEventListener('change', fixInputLimits);

/* init */
(function init(){
  // ensure canvas is square and a reasonable size on load
  const containerWidth = Math.min(720, Math.floor(window.innerWidth * 0.78));
  canvas.width = canvas.height = Math.max(420, containerWidth);
  generateMaze();
  // re-generate if user resizes window and canvas dimensions change substantially (keeps cell size sane)
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      const newW = Math.min(720, Math.floor(window.innerWidth * 0.78));
      const desired = Math.max(420, newW);
      if (Math.abs(desired - canvas.width) > 40) {
        canvas.width = canvas.height = desired;
        generateMaze();
      }
    }, 200);
  });
})();
</script>

</body>
</html>
