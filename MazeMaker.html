<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Random Maze Generator (Interactive Solver) - Single Snake</title>
<style>
  :root {
    --bg: #111;
    --panel: #222;
    --btn: #333;
    --muted: #ddd;
  }
  html,body { height:100%; margin:0; overflow:hidden; }
  body {
    background: var(--bg);
    color: var(--muted);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    display:flex;
    flex-direction:column;
    padding:20px;
    box-sizing:border-box;
  }

  #container {
    flex:1;
    display: grid;
    grid-template-columns: 1fr 260px;
    gap: 18px;
    overflow:hidden;
  }

  /* make maze scroll independently */
  #mazeWrapper {
    width:100%;
    height:100%;
    overflow:auto;
  }

  canvas {
    background: var(--panel);
    display:block;
    margin:0;
    image-rendering: pixelated;
    border-radius:6px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.6);
  }

  #controls {
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:stretch;
  }

  .row { display:flex; gap:8px; }
  input[type="number"], button {
    font-size:15px;
    padding:8px 10px;
    border-radius:8px;
    border:1px solid #444;
    background: var(--btn);
    color: #fff;
    box-sizing:border-box;
  }

  input[type="number"] { background:#1b1b1b; color:var(--muted); width:100%; }
  button { cursor:pointer; }

  #progressContainer { text-align:center; color:var(--muted); font-size:13px; display:none; }
  #progressBar { width:100%; height:12px; background:#111; border-radius:8px; overflow:hidden; border:1px solid #333; margin-top:6px; }
  #progressFill { height:100%; width:0%; transition: width 0.06s linear; background: linear-gradient(90deg,#00c853,#00b0ff); }

  @media print {
    body { background: white; color: black; }
    #controls { display:none !important; }
    #container { grid-template-columns: 1fr; }
    canvas { background: white !important; box-shadow:none !important; border-radius:0 !important; }
  }

  @media (max-width:900px) {
    #container { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<div id="container">
  <div id="mazeWrapper">
    <canvas id="maze" width="720" height="720"></canvas>
  </div>

  <div id="controls">
    <div class="row">
      <input id="rowsInput" type="number" value="30" min="5" max="100">
      <input id="colsInput" type="number" value="30" min="5" max="100">
    </div>

    <button id="newMazeBtn">NEW MAZE</button>
    <button id="printBtn">PRINT MAZE</button>
    <button id="solveBtn">START SOLVE</button>
    <button id="closeSolutionBtn" style="display:none;">CLOSE SOLVE</button>
    <button id="stopSolveBtn" style="display:none;">STOP SOLVING</button>

    <!-- NEW BUTTON -->
    <button id="goBackBtn">GO BACK</button>

    <div id="progressContainer">
      <div id="progressText">Progress: 0%</div>
      <div id="progressBar"><div id="progressFill"></div></div>
    </div>

  </div>
</div>

<script>
/* ---------- Maze Generator (single snake) ---------- */

const canvas = document.getElementById('maze');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById("mazeWrapper");

let rows = 30, cols = 30, size = 20;
const borderLineWidth = 3;
let grid = [];
let stack = [];
let mazeFinished = false;
let solving = false;
let interactivePath = null;
let totalCells = 0, visitedCount = 0;

function clamp(v,a,b){ return Math.max(a,Math.min(v,b)); }
function fixInputLimits(){
  const r=document.getElementById('rowsInput');
  const c=document.getElementById('colsInput');
  if(r.value>100) r.value=100;
  if(c.value>100) c.value=100;
}

class Cell {
  constructor(x,y){
    this.x=x; this.y=y;
    this.visited=false;
    this.walls={ top:true, right:true, bottom:true, left:true };
  }
  draw(){
    const x=this.x*size;
    const y=this.y*size;
    ctx.strokeStyle="#000";
    ctx.lineWidth=borderLineWidth;

    if(this.walls.top){ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x+size,y);ctx.stroke();}
    if(this.walls.right){ctx.beginPath();ctx.moveTo(x+size,y);ctx.lineTo(x+size,y+size);ctx.stroke();}
    if(this.walls.bottom){ctx.beginPath();ctx.moveTo(x+size,y+size);ctx.lineTo(x,y+size);ctx.stroke();}
    if(this.walls.left){ctx.beginPath();ctx.moveTo(x,y+size);ctx.lineTo(x,y);ctx.stroke();}
  }
}

function getNeighbors(cell){
  const neighbors=[];
  const dirs=[
    {dx:0,dy:-1,a:'top',b:'bottom'},
    {dx:1,dy:0,a:'right',b:'left'},
    {dx:0,dy:1,a:'bottom',b:'top'},
    {dx:-1,dy:0,a:'left',b:'right'}
  ];
  for(let d of dirs){
    const nx=cell.x+d.dx;
    const ny=cell.y+d.dy;
    if(nx>=0&&nx<cols&&ny>=0&&ny<rows){
      const n=grid[ny][nx];
      if(!n.visited) neighbors.push({cell:n,removeA:d.a,removeB:d.b});
    }
  }
  return neighbors;
}

function drawOuterBorder(){
  ctx.strokeStyle="#000";
  ctx.lineWidth=borderLineWidth;
  ctx.strokeRect(borderLineWidth/2,borderLineWidth/2,cols*size-borderLineWidth,rows*size-borderLineWidth);
}

function updateProgress(){
  const pct=Math.floor((visitedCount/totalCells)*100);
  document.getElementById('progressText').textContent=`Progress: ${pct}%`;
  document.getElementById('progressFill').style.width=`${pct}%`;
}

function drawMaze(){
  ctx.fillStyle="#fff";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      grid[y][x].draw();
    }
  }

  drawOuterBorder();

  if(interactivePath){
    const thin=Math.max(1,Math.floor(size*0.18));
    const bold=Math.max(1,Math.floor(size*0.34));

    if(interactivePath.length>2){
      ctx.strokeStyle="rgba(0,120,255,0.9)";
      ctx.lineWidth=thin;
      ctx.beginPath();
      const s=interactivePath[0];
      ctx.moveTo(s.x*size+size/2,s.y*size+size/2);
      for(let i=1;i<interactivePath.length-1;i++){
        const p=interactivePath[i];
        ctx.lineTo(p.x*size+size/2,p.y*size+size/2);
      }
      ctx.stroke();
    }

    if(interactivePath.length>1){
      ctx.strokeStyle="rgba(255,40,40,0.95)";
      ctx.lineWidth=bold;
      ctx.beginPath();
      const a=interactivePath[interactivePath.length-2];
      const b=interactivePath[interactivePath.length-1];
      ctx.moveTo(a.x*size+size/2,a.y*size+size/2);
      ctx.lineTo(b.x*size+size/2,b.y*size+size/2);
      ctx.stroke();
    }
  }

  ctx.fillStyle="lime";
  ctx.font=`${Math.max(12,Math.floor(size*0.8))}px Arial`;
  ctx.textBaseline="middle";
  ctx.fillText("S",size*0.28,size*0.5);
  ctx.fillStyle="red";
  ctx.fillText("E",(cols-1)*size+size*0.28,(rows-1)*size+size*0.5);

  updateProgress();
}

function generateMaze(){
  fixInputLimits();
  rows=clamp(parseInt(rowsInput.value)||30,5,100);
  cols=clamp(parseInt(colsInput.value)||30,5,100);

  size=Math.floor(Math.min(720/cols,720/rows));
  if(size<4) size=4;

  mazeFinished=false;
  solving=false;
  interactivePath=null;
  document.getElementById("closeSolutionBtn").style.display="none";
  document.getElementById("stopSolveBtn").style.display="none";
  document.getElementById("progressContainer").style.display="block";

  grid=[];
  for(let y=0;y<rows;y++){
    grid[y]=[];
    for(let x=0;x<cols;x++){
      grid[y][x]=new Cell(x,y);
    }
  }

  totalCells=rows*cols;
  visitedCount=0;

  let current=grid[0][0];
  current.visited=true;
  visitedCount++;
  stack=[];

  function step(){
    const neighbors=getNeighbors(current);
    if(neighbors.length>0){
      const ch=neighbors[Math.floor(Math.random()*neighbors.length)];
      const next=ch.cell;

      current.walls[ch.removeA]=false;
      next.walls[ch.removeB]=false;

      stack.push(current);
      next.visited=true;
      visitedCount++;
      current=next;
    } else if(stack.length>0){
      current=stack.pop();
    } else {
      mazeFinished=true;
      drawMaze();
      return;
    }
    drawMaze();
    updateProgress();
    requestAnimationFrame(step);
  }
  step();
}

/* ---------- Solve Mode ---------- */

function startInteractiveSolve(){
  if(!mazeFinished) return alert("Maze still generating!");
  solving=true;
  interactivePath=[{x:0,y:0}];
  document.getElementById("stopSolveBtn").style.display="block";
  document.getElementById("solveBtn").style.display="none";
}

function move(dx,dy){
  if(!solving) return;
  const last=interactivePath[interactivePath.length-1];
  const nx=last.x+dx;
  const ny=last.y+dy;
  if(nx<0||nx>=cols||ny<0||ny>=rows) return;

  const cell=grid[last.y][last.x];
  const canMove=(dx===0&&dy===-1&&!cell.walls.top)||
                (dx===1&&dy===0&&!cell.walls.right)||
                (dx===0&&dy===1&&!cell.walls.bottom)||
                (dx===-1&&dy===0&&!cell.walls.left);

  if(!canMove) return;

  if(last.x!==nx||last.y!==ny){
    interactivePath.push({x:nx,y:ny});
    drawMaze();
    if(nx===cols-1&&ny===rows-1){
      solving=false;
      alert("Maze finished!");
    }
  }
}

document.addEventListener("keydown",e=>{
  if(!solving) return;
  if(e.key==="ArrowUp"||e.key==="w") move(0,-1);
  if(e.key==="ArrowRight"||e.key==="d") move(1,0);
  if(e.key==="ArrowDown"||e.key==="s") move(0,1);
  if(e.key==="ArrowLeft"||e.key==="a") move(-1,0);
});

/* pointer solve */
let drag=false;

canvas.addEventListener("mousedown",e=>{
  if(!solving) return;
  drag=true;
  pointer(e.clientX,e.clientY);
});
window.addEventListener("mouseup",()=>drag=false);
canvas.addEventListener("mousemove",e=>{
  if(drag&&solving) pointer(e.clientX,e.clientY);
});

canvas.addEventListener("touchstart",e=>{
  if(!solving) return;
  drag=true;
  let t=e.touches[0];
  pointer(t.clientX,t.clientY);
  e.preventDefault();
},{passive:false});
canvas.addEventListener("touchmove",e=>{
  if(drag&&solving){
    let t=e.touches[0];
    pointer(t.clientX,t.clientY);
    e.preventDefault();
  }
},{passive:false});
window.addEventListener("touchend",()=>drag=false);

function pointer(x,y){
  const r=canvas.getBoundingClientRect();
  const cx=x-r.left;
  const cy=y-r.top;
  const gx=Math.floor(cx/size);
  const gy=Math.floor(cy/size);

  if(!interactivePath) return;
  const last=interactivePath[interactivePath.length-1];
  const dx=gx-last.x;
  const dy=gy-last.y;
  if(Math.abs(dx)+Math.abs(dy)===1){
    move(dx,dy);
  }
}

/* ---------- Buttons ---------- */

newMazeBtn.onclick=()=>{
  if(solving){
    if(!confirm("You are solving. Lose progress?")) return;
  }
  generateMaze();
};

printBtn.onclick=()=>{
  if(solving) return alert("Cannot print while solving!");
  if(!mazeFinished) return alert("Maze still generating!");
  window.print();
};

solveBtn.onclick=startInteractiveSolve;

closeSolutionBtn.onclick=()=>{
  solving=false;
  interactivePath=null;
  drawMaze();
};

stopSolveBtn.onclick=()=>{
  solving=false;
  interactivePath=null;
  drawMaze();
};

goBackBtn.onclick=()=>{
  window.location.href="index.html";
};

/* ---------- Auto Init ---------- */

(function(){
  generateMaze();
})();
</script>

</body>
</html>
